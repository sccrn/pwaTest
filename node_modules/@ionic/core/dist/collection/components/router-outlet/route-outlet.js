import { transition } from '../../utils';
import { attachComponent, detachComponent } from '../../utils/framework-delegate';
import iosTransitionAnimation from '../nav/animations/ios.transition';
import mdTransitionAnimation from '../nav/animations/md.transition';
export class RouterOutlet {
    constructor() {
        this.isTransitioning = false;
        this.activeEl = undefined;
    }
    componentWillLoad() {
        if (this.animated === undefined) {
            this.animated = this.config.getBoolean('animate', true);
        }
    }
    componentDidUnload() {
        this.activeEl = this.activeComponent = undefined;
    }
    async setRoot(component, params, opts) {
        if (this.isTransitioning || this.activeComponent === component) {
            return false;
        }
        this.activeComponent = component;
        // attach entering view to DOM
        const enteringEl = await attachComponent(this.delegate, this.el, component, ['ion-page', 'hide-page'], params);
        const leavingEl = this.activeEl;
        // commit animation
        await this.commit(enteringEl, leavingEl, opts);
        // remove leaving view
        this.activeEl = enteringEl;
        detachComponent(this.delegate, leavingEl);
        return true;
    }
    async commit(enteringEl, leavingEl, opts) {
        // isTransitioning acts as a lock to prevent reentering
        if (this.isTransitioning || leavingEl === enteringEl) {
            return false;
        }
        this.isTransitioning = true;
        // emit nav will change event
        this.ionNavWillChange.emit();
        opts = opts || {};
        await transition({
            animationBuilder: this.getAnimationBuilder(opts),
            direction: opts.direction,
            duration: opts.duration,
            easing: opts.easing,
            deepWait: opts.deepWait,
            animationCtrl: this.animationCtrl,
            showGoBack: opts.showGoBack,
            enteringEl: enteringEl,
            leavingEl: leavingEl,
            baseEl: this.el,
        });
        this.isTransitioning = false;
        // emit nav changed event
        this.ionNavDidChange.emit();
        return true;
    }
    async setRouteId(id, params, direction) {
        const changed = await this.setRoot(id, params, {
            duration: direction === 0 ? 0 : undefined,
            direction: direction === -1 ? "back" /* Back */ : "forward" /* Forward */,
        });
        return {
            changed,
            element: this.activeEl
        };
    }
    getRouteId() {
        const active = this.activeEl;
        return active ? {
            id: active.tagName,
            element: active,
        } : undefined;
    }
    getAnimationBuilder(opts) {
        if (opts.duration === 0 || this.animated === false) {
            return undefined;
        }
        const mode = opts.mode || this.config.get('pageTransition', this.mode);
        return opts.animationBuilder
            || this.animationBuilder
            || mode === 'ios' ? iosTransitionAnimation : mdTransitionAnimation;
    }
    render() {
        return [
            this.mode === 'ios' && h("div", { class: 'nav-decor' }),
            h("slot", null)
        ];
    }
    static get is() { return "ion-router-outlet"; }
    static get properties() { return { "animated": { "type": Boolean, "attr": "animated", "mutable": true }, "animationBuilder": { "type": "Any", "attr": "animation-builder" }, "animationCtrl": { "connect": "ion-animation-controller" }, "commit": { "method": true }, "config": { "context": "config" }, "delegate": { "type": "Any", "attr": "delegate" }, "el": { "elementRef": true }, "getRouteId": { "method": true }, "setRoot": { "method": true }, "setRouteId": { "method": true } }; }
    static get events() { return [{ "name": "ionNavWillChange", "method": "ionNavWillChange", "bubbles": true, "cancelable": true, "composed": true }, { "name": "ionNavDidChange", "method": "ionNavDidChange", "bubbles": true, "cancelable": true, "composed": true }]; }
}
