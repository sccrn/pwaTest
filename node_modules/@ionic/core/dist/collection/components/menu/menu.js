import { assert, isRightSide } from '../../utils/helpers';
export class Menu {
    constructor() {
        this.isPane = false;
        this._isOpen = false;
        this.lastOnEnd = 0;
        this.isAnimating = false;
        this.isRightSide = false;
        /**
         * If true, the menu is disabled. Default `false`.
         */
        this.disabled = false;
        /**
         * Which side of the view the menu should be placed. Default `"start"`.
         */
        this.side = 'start';
        /**
         * If true, swiping the menu is enabled. Default `true`.
         */
        this.swipeEnabled = true;
        /**
         * If true, the menu will persist on child pages.
         */
        this.persistent = false;
        this.maxEdgeStart = 50;
    }
    typeChanged(type, oldType) {
        const contentEl = this.contentEl;
        if (contentEl && oldType) {
            contentEl.classList.remove(`menu-content-${oldType}`);
            contentEl.classList.add(`menu-content-${type}`);
            contentEl.removeAttribute('style');
        }
        if (this.menuInnerEl) {
            // Remove effects of previous animations
            this.menuInnerEl.removeAttribute('style');
        }
        this.animation = undefined;
    }
    disabledChanged(disabled) {
        this.updateState();
        this.ionMenuChange.emit({ disabled: disabled, open: this._isOpen });
    }
    sideChanged() {
        this.isRightSide = isRightSide(this.side);
    }
    swipeEnabledChanged() {
        this.updateState();
    }
    async componentWillLoad() {
        this.menuCtrl = await this.lazyMenuCtrl.componentOnReady();
        if (this.type == null) {
            this.type = this.mode === 'ios' ? 'reveal' : 'overlay';
        }
    }
    componentDidLoad() {
        if (this.isServer) {
            return;
        }
        const el = this.el;
        const content = (this.contentId)
            ? document.getElementById(this.contentId)
            : el.parentElement.querySelector('[main]');
        if (!content || !content.tagName) {
            // requires content element
            return console.error('Menu: must have a "content" element to listen for drag events on.');
        }
        this.contentEl = content;
        // add menu's content classes
        content.classList.add('menu-content');
        this.typeChanged(this.type, null);
        this.sideChanged();
        let isEnabled = !this.disabled;
        if (isEnabled === true || typeof isEnabled === 'undefined') {
            const menus = this.menuCtrl.getMenus();
            isEnabled = !menus.some(m => {
                return m.side === this.side && !m.disabled;
            });
        }
        // register this menu with the app's menu controller
        this.menuCtrl._register(this);
        this.ionMenuChange.emit({ disabled: !isEnabled, open: this._isOpen });
        // mask it as enabled / disabled
        this.disabled = !isEnabled;
    }
    componentDidUnload() {
        this.menuCtrl._unregister(this);
        this.animation && this.animation.destroy();
        this.menuCtrl = this.animation = undefined;
        this.contentEl = this.backdropEl = this.menuInnerEl = undefined;
    }
    splitPaneChanged(ev) {
        this.isPane = ev.target.isPane(this.el);
        this.updateState();
    }
    onBackdropClick(ev) {
        const el = ev.target;
        if (!el.closest('.menu-inner') && this.lastOnEnd < (ev.timeStamp - 100)) {
            ev.preventDefault();
            ev.stopPropagation();
            this.close();
        }
    }
    isOpen() {
        return this._isOpen;
    }
    open(animated = true) {
        return this.setOpen(true, animated);
    }
    close(animated = true) {
        return this.setOpen(false, animated);
    }
    toggle(animated = true) {
        return this.setOpen(!this._isOpen, animated);
    }
    setOpen(shouldOpen, animated = true) {
        return this.menuCtrl._setOpen(this, shouldOpen, animated);
    }
    async _setOpen(shouldOpen, animated = true) {
        // If the menu is disabled or it is currenly being animated, let's do nothing
        if (!this.isActive() || this.isAnimating || (shouldOpen === this._isOpen)) {
            return this._isOpen;
        }
        this.beforeAnimation();
        await this.loadAnimation();
        await this.startAnimation(shouldOpen, animated);
        this.afterAnimation(shouldOpen);
        return shouldOpen;
    }
    isActive() {
        return !this.disabled && !this.isPane;
    }
    async loadAnimation() {
        // Menu swipe animation takes the menu's inner width as parameter,
        // If `offsetWidth` changes, we need to create a new animation.
        const width = this.menuInnerEl.offsetWidth;
        if (width === this.width && this.animation !== undefined) {
            return;
        }
        this.width = width;
        // Destroy existing animation
        if (this.animation) {
            this.animation.destroy();
            this.animation = undefined;
        }
        // Create new animation
        this.animation = await this.menuCtrl.createAnimation(this.type, this);
    }
    async startAnimation(shouldOpen, animated) {
        const ani = this.animation.reverse(!shouldOpen);
        if (animated) {
            await ani.playAsync();
        }
        else {
            ani.playSync();
        }
    }
    canSwipe() {
        return this.swipeEnabled &&
            !this.isAnimating &&
            this.isActive();
    }
    canStart(detail) {
        if (!this.canSwipe()) {
            return false;
        }
        if (this._isOpen) {
            return true;
        }
        else if (this.menuCtrl.getOpen()) {
            return false;
        }
        return checkEdgeSide(detail.currentX, this.isRightSide, this.maxEdgeStart);
    }
    onWillStart() {
        this.beforeAnimation();
        return this.loadAnimation();
    }
    onDragStart() {
        assert(!!this.animation, '_type is undefined');
        if (!this.isAnimating) {
            assert(false, 'isAnimating has to be true');
            return;
        }
        // the cloned animation should not use an easing curve during seek
        this.animation
            .reverse(this._isOpen)
            .progressStart();
    }
    onDragMove(detail) {
        assert(!!this.animation, '_type is undefined');
        if (!this.isAnimating) {
            assert(false, 'isAnimating has to be true');
            return;
        }
        const delta = computeDelta(detail.deltaX, this._isOpen, this.isRightSide);
        const stepValue = delta / this.width;
        this.animation.progressStep(stepValue);
    }
    onDragEnd(detail) {
        assert(!!this.animation, '_type is undefined');
        if (!this.isAnimating) {
            assert(false, 'isAnimating has to be true');
            return;
        }
        const isOpen = this._isOpen;
        const isRightSide = this.isRightSide;
        const delta = computeDelta(detail.deltaX, isOpen, isRightSide);
        const width = this.width;
        const stepValue = delta / width;
        const velocity = detail.velocityX;
        const z = width / 2.0;
        const shouldCompleteRight = (velocity >= 0)
            && (velocity > 0.2 || detail.deltaX > z);
        const shouldCompleteLeft = (velocity <= 0)
            && (velocity < -0.2 || detail.deltaX < -z);
        const shouldComplete = (isOpen)
            ? isRightSide ? shouldCompleteRight : shouldCompleteLeft
            : isRightSide ? shouldCompleteLeft : shouldCompleteRight;
        let shouldOpen = (!isOpen && shouldComplete);
        if (isOpen && !shouldComplete) {
            shouldOpen = true;
        }
        const missing = shouldComplete ? 1 - stepValue : stepValue;
        const missingDistance = missing * width;
        let realDur = 0;
        if (missingDistance > 5) {
            const dur = missingDistance / Math.abs(velocity);
            realDur = Math.min(dur, 300);
        }
        this.lastOnEnd = detail.timeStamp;
        this.animation
            .onFinish(() => this.afterAnimation(shouldOpen), { clearExistingCallacks: true })
            .progressEnd(shouldComplete, stepValue, realDur);
    }
    beforeAnimation() {
        assert(!this.isAnimating, '_before() should not be called while animating');
        // this places the menu into the correct location before it animates in
        // this css class doesn't actually kick off any animations
        this.el.classList.add(SHOW_MENU);
        this.backdropEl.classList.add(SHOW_BACKDROP);
        this.isAnimating = true;
    }
    afterAnimation(isOpen) {
        assert(this.isAnimating, '_before() should be called while animating');
        // keep opening/closing the menu disabled for a touch more yet
        // only add listeners/css if it's enabled and isOpen
        // and only remove listeners/css if it's not open
        // emit opened/closed events
        this._isOpen = isOpen;
        this.isAnimating = false;
        // add/remove backdrop click listeners
        this.enableListener(this, 'body:click', isOpen);
        if (isOpen) {
            // add css class
            this.contentEl.classList.add(MENU_CONTENT_OPEN);
            // emit open event
            this.ionOpen.emit();
        }
        else {
            // remove css classes
            this.el.classList.remove(SHOW_MENU);
            this.contentEl.classList.remove(MENU_CONTENT_OPEN);
            this.backdropEl.classList.remove(SHOW_BACKDROP);
            // emit close event
            this.ionClose.emit();
        }
    }
    updateState() {
        const isActive = this.isActive();
        // Close menu inmediately
        if (!isActive && this._isOpen) {
            // close if this menu is open, and should not be enabled
            this.forceClosing();
        }
        if (!this.disabled && this.menuCtrl) {
            this.menuCtrl._setActiveMenu(this);
        }
        assert(!this.isAnimating, 'can not be animating');
    }
    forceClosing() {
        assert(this._isOpen, 'menu cannot be closed');
        this.isAnimating = true;
        this.startAnimation(false, false);
        this.afterAnimation(false);
    }
    hostData() {
        const isRightSide = this.isRightSide;
        return {
            role: 'complementary',
            class: {
                [`menu-type-${this.type}`]: true,
                'menu-enabled': !this.disabled,
                'menu-side-right': isRightSide,
                'menu-side-left': !isRightSide,
            }
        };
    }
    render() {
        return ([
            h("div", { class: 'menu-inner', ref: el => this.menuInnerEl = el },
                h("slot", null)),
            h("ion-backdrop", { ref: el => this.backdropEl = el, class: 'menu-backdrop', tappable: false, stopPropagation: false }),
            h("ion-gesture", Object.assign({}, {
                'canStart': this.canStart.bind(this),
                'onWillStart': this.onWillStart.bind(this),
                'onStart': this.onDragStart.bind(this),
                'onMove': this.onDragMove.bind(this),
                'onEnd': this.onDragEnd.bind(this),
                'maxEdgeStart': this.maxEdgeStart,
                'edge': this.side,
                'disabled': !this.isActive() || !this.swipeEnabled,
                'gestureName': 'menu-swipe',
                'gesturePriority': 10,
                'type': 'pan',
                'direction': 'x',
                'threshold': 10,
                'attachTo': 'window',
                'disableScroll': true,
            }))
        ]);
    }
    static get is() { return "ion-menu"; }
    static get host() { return { "theme": "menu" }; }
    static get properties() { return { "close": { "method": true }, "config": { "context": "config" }, "contentId": { "type": String, "attr": "content-id" }, "disabled": { "type": Boolean, "attr": "disabled", "mutable": true, "watchCallbacks": ["disabledChanged"] }, "el": { "elementRef": true }, "enableListener": { "context": "enableListener" }, "isActive": { "method": true }, "isOpen": { "method": true }, "isRightSide": { "state": true }, "isServer": { "context": "isServer" }, "lazyMenuCtrl": { "connect": "ion-menu-controller" }, "maxEdgeStart": { "type": Number, "attr": "max-edge-start" }, "menuId": { "type": String, "attr": "menu-id" }, "open": { "method": true }, "persistent": { "type": Boolean, "attr": "persistent" }, "setOpen": { "method": true }, "side": { "type": "Any", "attr": "side", "watchCallbacks": ["sideChanged"] }, "swipeEnabled": { "type": Boolean, "attr": "swipe-enabled", "watchCallbacks": ["swipeEnabledChanged"] }, "toggle": { "method": true }, "type": { "type": String, "attr": "type", "mutable": true, "watchCallbacks": ["typeChanged"] } }; }
    static get events() { return [{ "name": "ionOpen", "method": "ionOpen", "bubbles": true, "cancelable": true, "composed": true }, { "name": "ionClose", "method": "ionClose", "bubbles": true, "cancelable": true, "composed": true }, { "name": "ionMenuChange", "method": "ionMenuChange", "bubbles": true, "cancelable": true, "composed": true }]; }
    static get style() { return "/**style-placeholder:ion-menu:**/"; }
    static get styleMode() { return "/**style-id-placeholder:ion-menu:**/"; }
}
function computeDelta(deltaX, isOpen, isRightSide) {
    return Math.max(0, (isOpen !== isRightSide) ? -deltaX : deltaX);
}
function checkEdgeSide(posX, isRightSide, maxEdgeStart) {
    if (isRightSide) {
        return posX >= window.innerWidth - maxEdgeStart;
    }
    else {
        return posX <= maxEdgeStart;
    }
}
const SHOW_MENU = 'show-menu';
const SHOW_BACKDROP = 'show-backdrop';
const MENU_CONTENT_OPEN = 'menu-content-open';
