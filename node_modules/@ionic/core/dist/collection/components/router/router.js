import { flattenRouterTree, readRedirects, readRoutes } from './utils/parser';
import { readNavState, writeNavState } from './utils/dom';
import { chainToPath, generatePath, parsePath, readPath, writePath } from './utils/path';
import { routeRedirect, routerIDsToChain, routerPathToChain } from './utils/matching';
export class Router {
    constructor() {
        this.previousPath = null;
        this.busy = false;
        this.init = false;
        this.state = 0;
        this.lastState = 0;
        this.base = '';
        this.useHash = true;
    }
    componentDidLoad() {
        this.init = true;
        console.debug('[ion-router] router did load');
        const tree = readRoutes(this.el);
        this.routes = flattenRouterTree(tree);
        this.redirects = readRedirects(this.el);
        // TODO: use something else
        requestAnimationFrame(() => {
            this.historyDirection();
            this.writeNavStateRoot(this.getPath(), 0 /* None */);
        });
    }
    onRedirectChanged(ev) {
        if (!this.init) {
            return;
        }
        console.debug('[ion-router] redirect data changed', ev.target);
        this.redirects = readRedirects(this.el);
    }
    onRoutesChanged(ev) {
        if (!this.init) {
            return;
        }
        console.debug('[ion-router] route data changed', ev.target, ev.detail);
        // schedule write
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = undefined;
        }
        this.timer = setTimeout(() => {
            console.debug('[ion-router] data changed -> update nav');
            const tree = readRoutes(this.el);
            this.routes = flattenRouterTree(tree);
            this.writeNavStateRoot(this.getPath(), 0 /* None */);
            this.timer = undefined;
        }, 100);
    }
    onPopState() {
        const direction = this.historyDirection();
        const path = this.getPath();
        console.debug('[ion-router] URL changed -> update nav', path, direction);
        return this.writeNavStateRoot(path, direction);
    }
    historyDirection() {
        if (window.history.state === null) {
            this.state++;
            window.history.replaceState(this.state, document.title, document.location.href);
        }
        const state = window.history.state;
        const lastState = this.lastState;
        this.lastState = state;
        if (state > lastState) {
            return 1 /* Forward */;
        }
        else if (state < lastState) {
            return -1 /* Back */;
        }
        else {
            return 0 /* None */;
        }
    }
    async navChanged(direction) {
        if (this.busy) {
            return false;
        }
        const { ids, outlet } = readNavState(document.body);
        const chain = routerIDsToChain(ids, this.routes);
        if (!chain) {
            console.warn('[ion-router] no matching URL for ', ids.map(i => i.id));
            return false;
        }
        const path = chainToPath(chain);
        if (!path) {
            console.warn('[ion-router] router could not match path because some required param is missing');
            return false;
        }
        console.debug('[ion-router] nav changed -> update URL', ids, path);
        this.setPath(path, direction);
        if (outlet) {
            console.debug('[ion-router] updating nested outlet', outlet);
            await this.writeNavState(outlet, chain, 0 /* None */, ids.length);
        }
        this.emitRouteChange(path, null);
        return true;
    }
    push(url, direction = 1 /* Forward */) {
        const path = parsePath(url);
        this.setPath(path, direction);
        console.debug('[ion-router] URL pushed -> updating nav', url, direction);
        return this.writeNavStateRoot(path, direction);
    }
    async writeNavStateRoot(path, direction) {
        if (this.busy) {
            return false;
        }
        const redirect = routeRedirect(path, this.redirects);
        let redirectFrom = null;
        if (redirect) {
            this.setPath(redirect.to, direction);
            redirectFrom = redirect.from;
            path = redirect.to;
        }
        const chain = routerPathToChain(path, this.routes);
        const changed = await this.writeNavState(document.body, chain, direction);
        if (changed) {
            this.emitRouteChange(path, redirectFrom);
        }
        return changed;
    }
    async writeNavState(node, chain, direction, index = 0) {
        if (this.busy) {
            return false;
        }
        this.busy = true;
        const changed = await writeNavState(node, chain, direction, index);
        this.busy = false;
        return changed;
    }
    setPath(path, direction) {
        this.state++;
        writePath(window.history, this.base, this.useHash, path, direction, this.state);
    }
    getPath() {
        return readPath(window.location, this.base, this.useHash);
    }
    emitRouteChange(path, redirectPath) {
        console.debug('[ion-router] route changed', path);
        const from = this.previousPath;
        const redirectedFrom = redirectPath ? generatePath(redirectPath) : null;
        const to = generatePath(path);
        this.previousPath = to;
        this.ionRouteChanged.emit({
            from,
            redirectedFrom,
            to: to
        });
    }
    static get is() { return "ion-router"; }
    static get properties() { return { "base": { "type": String, "attr": "base" }, "config": { "context": "config" }, "dom": { "context": "dom" }, "el": { "elementRef": true }, "navChanged": { "method": true }, "push": { "method": true }, "useHash": { "type": Boolean, "attr": "use-hash" } }; }
    static get events() { return [{ "name": "ionRouteChanged", "method": "ionRouteChanged", "bubbles": true, "cancelable": true, "composed": true }]; }
}
