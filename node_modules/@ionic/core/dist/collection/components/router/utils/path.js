export function generatePath(segments) {
    const path = segments
        .filter(s => s.length > 0)
        .join('/');
    return '/' + path;
}
export function chainToPath(chain) {
    const path = [];
    for (const route of chain) {
        for (const segment of route.path) {
            if (segment[0] === ':') {
                const param = route.params && route.params[segment.slice(1)];
                if (!param) {
                    return null;
                }
                path.push(param);
            }
            else if (segment !== '') {
                path.push(segment);
            }
        }
    }
    return path;
}
export function writePath(history, base, usePath, path, direction, state) {
    path = [base, ...path];
    let url = generatePath(path);
    if (usePath) {
        url = '#' + url;
    }
    if (direction === 1 /* Forward */) {
        history.pushState(state, '', url);
    }
    else {
        history.replaceState(state, '', url);
    }
}
export function readPath(loc, base, useHash) {
    const path = useHash
        ? loc.hash.substr(1)
        : loc.pathname;
    if (path.startsWith(base)) {
        return parsePath(path.slice(base.length));
    }
    return null;
}
export function parsePath(path) {
    if (path == null) {
        return [''];
    }
    const segments = path.split('/')
        .map(s => s.trim())
        .filter(s => s.length > 0);
    if (segments.length === 0) {
        return [''];
    }
    else {
        return segments;
    }
}
